# Creative Labs Frontend Stack

## Table of Contents

* [Introduction](#introduction)
* [Package management](#package-management)
  * [`package.json`](#packagejson)
  * [Managing dependencies](#managing-dependencies)
  * [Versions](#versions)
  * [Lockfiles](#lockfiles)
* [UI Framework](#ui-framework)
* [Bundling](#bundling)

## Introduction

The purpose of this documentation is to explain our frontend stack, including how each major component roughly works, why we chose that specific technology instead of the alternatives, and how you can use it.
This includes:
* **Package manager**: Packages allow for additional functionality in an easily manageable form. We primarily use [Yarn](https://yarnpkg.com/).
* **UI Framework:** Choosing a framework (or deciding whether you even need one!) can make your life a lot easier, depending on the scale and complexity of your website. We use either vanilla [React](https://reactjs.org/) or no framework at all.
* **Bundling**: This is the process of taking all of your scripts, assets, and styles, and automatically combining them with one or more HTML files in a way that is more easily distributable. We use [Webpack](https://webpack.js.org/).

## Package management

Packages are distributed libraries that allow you to quickly and easily extend the functionality of your website without needing to spin it all up yourself or manually add libraries using `<link>` tags.
You use a _package manager_ to---you guessed it---manage these packages.

You've probably heard of NPM, the Node Package Manager, which is pretty much the default package manager for any JavaScript-based application (frontend and backend alike), but there are a few alternatives as well.
Our package manager of choice is [Yarn](https://yarnpkg.com/).
The two are very similar in usage: both use `package.json` files (see below) to manage dependencies and scripts, both generate lockfiles (again, see below), both use the same package registry, etc, etc.
However, we think Yarn does a couple of things better:
* Yarn's faster, since it downloads packages in parallel, whereas NPM downloads packages sequentially.
* The lockfile generated by Yarn (called `yarn.lock`) won't change if the dependencies and their versions listed in `package.json` don't change, while NPM's lockfile (called `package.lock`) can change (more on why this is a problem below).

For the rest of this documentation, we'll assume you're using Yarn.

### `package.json`

As mentioned earlier, the central hub for your project's dependencies and build scripts is the `package.json` file, which looks roughly like this:

```json
{
  "private": true,
  "scripts": {
    "start": "<some command> <with> <various> <parameters>",
    "build": "<another command>",
    "lint": "<something something>",
    ...
  },
  "dependencies": {
    "<package>": "<version>",
    "<another package>": "<version>",
    ...
  },
  "devDependencies": {
    "<more packages>": "<version>",
    ...
  }
}
```

Let's go through this one line-by-line.

#### `"private": true`
Many repositories are published to the official NPM package registry for general use. While this is great and all, that isn't usually our goal, so this flag just makes sure our repository can't be accidentally published. Totally optional, but good to have.

#### `"scripts": { ... }`
Inside this, you can define convenient aliases for a series of scripts and/or commands; you'd call these aliases using the `yarn` command.  
    For example, here's a script from our [sunshine](https://github.com/UCLA-Creative-Labs/sunshine/blob/master/package.json) repository's `package.json`:
    ```
    "start": "webpack-dev-server --open --config webpack.dev.js --host=0.0.0.0"
    ```
    This command with these parameters basically hosts the frontend on a development server running on `http://0.0.0.0` (see [*Bundling*](#bundling) below for more details on Webpack).
    This way, instead of needing to type the entire command, you can just run `yarn start`!
    Easy peasy.  
    Common aliases used are `"start"`, `"build"` (for generating distribution builds), and `"lint"` (runs a _linter_ on full source tree).

#### `"dependencies"` and `"devDependencies"`

Here's the real meat of the file, where all of your project's dependencies and their versions are listed.
The only real difference between `devDependencies` and regular `dependencies` is that `dependencies` contain those dependencies which are directly related to the running of your website while `devDependencies` are those which are mainly needed for developing and building the project.
There's a lot we want to say about these two, so let's take this to a new section.

### Managing dependencies

For the most part, you won't need to modify `dependencies` and `devDependencies` manually.
Instead, you can just use the holy trinity of package management commands (anything inside `[]` is optional):
```bash
$ yarn add [-D|--dev] <package>[@<version>]...
$ yarn install
$ yarn remove <package>
```

`yarn add` is, as you might expect, how you add new dependencies to your project (if you've used `npm`, it's equivalent to `npm install --save`).
Adding a `-D` or `--dev` saves the supplied dependencies to `devDependencies` (like `npm install --save-dev`).
You can also use `yarn add` to update the version of an already-installed package.

`yarn install` simply installs whatever packages are listed in `package.json`, and `yarn remove` removes one or more packages.

(You can run `yarn --help` or `yarn <command> --help` for more information about the various arguments that can be passed to Yarn).

### Versions

Let's take a closer look at the `<version>` bits from the last sections.
NPM packages use a versioning system known as _semantic versioning_, or _semver_ for short.
The structure of a semantic version number is:
```
<major>.<minor>.<patch>
```
Here, the `<major>` version number increments whenever there is a major change to the package which is incompatible to some degree with the previous major version, such as if there is a major overhaul to a application or API.
The `<minor>` version number increments whenever there is added or modified functionality that is backwards compatible with previous versions.
The `<patch>` version number is for small, backwards compatible bugfixes.

NPM, and by extension Yarn, have special syntax for specifying package versions such that the specific full version number is reasonably flexible:
* Use `<major>.<minor>`, `<major>.<minor>.x`, or `~<major>.<minor>.<minimum patch>` to keep the major and minor version fixed while allowing the patch number to change. For example, using `1.0`, `1.0.x`, or `~1.0.0` will automatically update you to the latest release between `1.0.0` and `<1.1.0`.
* Use `<major>`, `<major>.x`, or `^<major>.<minimum minor>.<minimum patch>` to keep the major version fixed while allowing the minor and patch version numbers to change. For example, using `2`, `2.x`, or `^2.3.1` will automatically update you to the latest release up until `<3.0.0` (and, in the case of the third one, will ensure that your version is at least `2.3.1`).
* Use `*` or `x` to allow the major version to change. This is not recommended.

Generally, if you're not sure about the versions you want, it is a good rule of thumb to stick with the caret `^`, letting the minor and patch versions change while keeping the major version fixed, as this allows you to get the latest bugfixes and improvements without (for the most part) running the risk of updating into a breaking change.
To that end, if you don't supply a specific version for a package to `yarn add`, it will automatically install the latest version of that package and then prepend a caret to make sure the major version doesn't change automatically.

### Lockfiles

This semantic versioning stuff is great and all, but how do you know if package owners are actually following those guidelines?
The answer is: you don't.
Plus, when you're working on a project with a team (such as your friends here at CL), if one person is on a higher minor or patch version than the other, then the former may be able to use functionality that does not work or even exist for the latter, leading to complications.

That's where _lockfiles_ come in.

Lockfiles are automatically generated when you install packages for the first time, usually with the extension `.lock`.
For example, Yarn's generated lockfile is called `yarn.lock`, while NPM's is just `package.lock`.
These lockfiles contain information about each and every package that is installed, those package's dependencies, those dependencies' dependencies, and so on.
This information includes:
* **Fixed** version numbers. 
* The fully-resolved URL from which the package was sourced.
* A SHA-512 hash that can be used to verify the integrity of the package.
* All further dependencies of the package.

Notice how "fixed" is in bold.
That's the primary purpose of the lockfile: to _lock_ the version of each package in place.
Whenever you run `yarn add|install` (or `npm install`), the tool first looks for a lockfile in the working directory.
If it finds one, it simply installs the versions listed in the lockfile for every package, and then moves on to `package.json` in case there are any packages not listed in the lockfile.
If not, it installs all the packages listed in `package.json` according to their specified versions, and then locks the newly-installed versions in place by generating a new lockfile.

You may already have guessed this (and NPM and Yarn generally tell you this the first time they create a lockfile), but:

_Commit your lockfiles to your repository._

This will make sure everyone working on the project is operating with the _exact same versions_ of each package.

Also, 99.999% of the time, you do not need to manually modify a generated lockfile.
In fact, you don't even need to open it, unless you would like to vet every installed dependency yourself.
The only times this file should be changing is if a new package or version is added to `package.json`, or if you want to manually update all your packages (in which case you simply delete and regenerate the lockfile).

## UI Framework

## Bundling
