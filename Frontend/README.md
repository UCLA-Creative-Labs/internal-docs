# Creative Labs Frontend Stack

## Table of Contents

* [Introduction](#introduction)
* [Package management](#package-management)
  * [`package.json`](#packagejson)
  * [Managing dependencies](#managing-dependencies)
  * [Versions](#versions)
  * [Lockfiles](#lockfiles)
* [UI Framework](#ui-framework)
  * [Do you even need a framework?](#do-you-even-need-a-framework)
  * [React](#react)
* [Bundling](#bundling)

## Introduction

The purpose of this documentation is to explain our frontend stack, including how each major component roughly works, why we chose that specific technology instead of the alternatives, and how you can use it.
This includes:
* **Package manager**: Packages allow for additional functionality in an easily manageable form. We primarily use [Yarn](https://yarnpkg.com/).
* **UI Framework:** Choosing a framework (or deciding whether you even need one!) can make your life a lot easier, depending on the scale and complexity of your website. We use either vanilla [React](https://reactjs.org/) or no framework at all.
* **Bundling**: This is the process of taking all of your scripts, assets, and styles, and automatically combining them with one or more HTML files in a way that is more easily distributable. We use [Webpack](https://webpack.js.org/).

## Package management

Packages are distributed libraries that allow you to quickly and easily extend the functionality of your website without needing to spin it all up yourself or manually add libraries using `<link>` tags.
You use a _package manager_ to---you guessed it---manage these packages.

You've probably heard of NPM, the Node Package Manager, which is pretty much the default package manager for any JavaScript-based application (frontend and backend alike), but there are a few alternatives as well.
Our package manager of choice is [Yarn](https://yarnpkg.com/).
The two are very similar in usage: both use `package.json` files (see below) to manage dependencies and scripts, both generate lockfiles (again, see below), both use the same package registry, etc, etc.
However, we think Yarn does a couple of things better:
* Yarn's faster, since it downloads packages in parallel, whereas NPM downloads packages sequentially.
* The lockfile generated by Yarn (called `yarn.lock`) won't change if the dependencies and their versions listed in `package.json` don't change, while NPM's lockfile (called `package.lock`) can change (more on why this is a problem below).

For the rest of this documentation, we'll assume you're using Yarn.

### `package.json`

As mentioned earlier, the central hub for your project's dependencies and build scripts is the `package.json` file, which looks roughly like this:

```json
{
  "private": true,
  "scripts": {
    "start": "<some command> <with> <various> <parameters>",
    "build": "<another command>",
    "lint": "<something something>",
    ...
  },
  "dependencies": {
    "<package>": "<version>",
    "<another package>": "<version>",
    ...
  },
  "devDependencies": {
    "<more packages>": "<version>",
    ...
  }
}
```

Let's go through this one line-by-line.

#### `"private": true`
Many repositories are published to the official NPM package registry for general use. While this is great and all, that isn't usually our goal, so this flag just makes sure our repository can't be accidentally published. Totally optional, but good to have.

#### `"scripts": { ... }`
Inside this, you can define convenient aliases for a series of scripts and/or commands; you'd call these aliases using the `yarn` command.  
    For example, here's a script from our [sunshine](https://github.com/UCLA-Creative-Labs/sunshine/blob/master/package.json) repository's `package.json`:
    ```
    "start": "webpack-dev-server --open --config webpack.dev.js --host=0.0.0.0"
    ```
    This command with these parameters basically hosts the frontend on a development server running on `http://0.0.0.0` (see [*Bundling*](#bundling) below for more details on Webpack).
    This way, instead of needing to type the entire command, you can just run `yarn start`!
    Easy peasy.  
    Common aliases used are `"start"`, `"build"` (for generating distribution builds), and `"lint"` (runs a _linter_ on full source tree).

#### `"dependencies"` and `"devDependencies"`

Here's the real meat of the file, where all of your project's dependencies and their versions are listed.
The only real difference between `devDependencies` and regular `dependencies` is that `dependencies` contain those dependencies which are directly related to the running of your website while `devDependencies` are those which are mainly needed for developing and building the project.
There's a lot we want to say about these two, so let's take this to a new section.

### Managing dependencies

For the most part, you won't need to modify `dependencies` and `devDependencies` manually.
Instead, you can just use the holy trinity of package management commands (anything inside `[]` is optional):
```bash
$ yarn add [-D|--dev] <package>[@<version>]...
$ yarn install
$ yarn remove <package>
```

`yarn add` is, as you might expect, how you add new dependencies to your project (if you've used `npm`, it's equivalent to `npm install --save`).
Adding a `-D` or `--dev` saves the supplied dependencies to `devDependencies` (like `npm install --save-dev`).
You can also use `yarn add` to update the version of an already-installed package.

`yarn install` simply installs whatever packages are listed in `package.json`, and `yarn remove` removes one or more packages.

(You can run `yarn --help` or `yarn <command> --help` for more information about the various arguments that can be passed to Yarn).

### Versions

Let's take a closer look at the `<version>` bits from the last sections.
NPM packages use a versioning system known as _semantic versioning_, or _semver_ for short.
The structure of a semantic version number is:
```
<major>.<minor>.<patch>
```
Here, the `<major>` version number increments whenever there is a major change to the package which is incompatible to some degree with the previous major version, such as if there is a major overhaul to a application or API.
The `<minor>` version number increments whenever there is added or modified functionality that is backwards compatible with previous versions.
The `<patch>` version number is for small, backwards compatible bugfixes.

NPM, and by extension Yarn, have special syntax for specifying package versions such that the specific full version number is reasonably flexible:
* Use `<major>.<minor>`, `<major>.<minor>.x`, or `~<major>.<minor>.<minimum patch>` to keep the major and minor version fixed while allowing the patch number to change. For example, using `1.0`, `1.0.x`, or `~1.0.0` will automatically update you to the latest release between `1.0.0` and `<1.1.0`.
* Use `<major>`, `<major>.x`, or `^<major>.<minimum minor>.<minimum patch>` to keep the major version fixed while allowing the minor and patch version numbers to change. For example, using `2`, `2.x`, or `^2.3.1` will automatically update you to the latest release up until `<3.0.0` (and, in the case of the third one, will ensure that your version is at least `2.3.1`).
* Use `*` or `x` to allow the major version to change. This is not recommended.

Generally, if you're not sure about the versions you want, it is a good rule of thumb to stick with the caret `^`, letting the minor and patch versions change while keeping the major version fixed, as this allows you to get the latest bugfixes and improvements without (for the most part) running the risk of updating into a breaking change.
To that end, if you don't supply a specific version for a package to `yarn add`, it will automatically install the latest version of that package and then prepend a caret to make sure the major version doesn't change automatically.

### Lockfiles

This semantic versioning stuff is great and all, but how do you know if package owners are actually following those guidelines?
The answer is: you don't.
Plus, when you're working on a project with a team (such as your friends here at CL), if one person is on a higher minor or patch version than the other, then the former may be able to use functionality that does not work or even exist for the latter, leading to complications.

That's where _lockfiles_ come in.

Lockfiles are automatically generated when you install packages for the first time, usually with the extension `.lock`.
For example, Yarn's generated lockfile is called `yarn.lock`, while NPM's is just `package.lock`.
These lockfiles contain information about each and every package that is installed, those package's dependencies, those dependencies' dependencies, and so on.
This information includes:
* **Fixed** version numbers. 
* The fully-resolved URL from which the package was sourced.
* A SHA-512 hash that can be used to verify the integrity of the package.
* All further dependencies of the package.

Notice how "fixed" is in bold.
That's the primary purpose of the lockfile: to _lock_ the version of each package in place.
Whenever you run `yarn add|install` (or `npm install`), the tool first looks for a lockfile in the working directory.
If it finds one, it simply installs the versions listed in the lockfile for every package, and then moves on to `package.json` in case there are any packages not listed in the lockfile.
If not, it installs all the packages listed in `package.json` according to their specified versions, and then locks the newly-installed versions in place by generating a new lockfile.

You may already have guessed this (and NPM and Yarn generally tell you this the first time they create a lockfile), but:

_Commit your lockfiles to your repository._

This will make sure everyone working on the project is operating with the _exact same versions_ of each package.

Also, 99.999% of the time, you do not need to manually modify a generated lockfile.
In fact, you don't even need to open it, unless you would like to vet every installed dependency yourself.
The only times this file should be changing is if a new package or version is added to `package.json`, or if you want to manually update all your packages (in which case you simply delete and regenerate the lockfile).

### Aside: Overreliance on Packages

While it is good to use packages, as you want to avoid reinventing the proverbial wheel and wasting development time and energy, there is such a thing as too many packages.
When you use too many packages, you open yourself up to a few problems:
* The size of your website's files will balloon, which mean your website will take longer to load for users. The user experience suffers as a result.
* You may lose out on much-needed flexibility if you choose to implement an important feature of your website using a package. Home-grown functionality allows you to have very fine-grained control over how it works, especially in tandem with the rest of your project.
* Package dependencies are _transitive_, meaning whenever you install one package, you install all its dependencies, recursively. This means you open yourself up to running the risk of installing malicious code (malicious either to your local system or to your website and its users), so exercise caution.
* More packages installed means more packages to keep track of. It's just more mental load that might not be necessary.

## UI Framework

There are tons of JavaScript UI frameworks out there, and each one has its pros and cons.
We're not going to talk about all of them (but if you're interested in the alternatives, there are about
[thirty](https://medium.com/javascript-in-plain-english/top-5-in-demand-javascript-frameworks-for-front-end-development-in-2020-a59c4340d082)
[four](https://medium.com/javascript-scene/top-javascript-frameworks-and-topics-to-learn-in-2020-and-the-new-decade-ced6e9d812f9)
[million](https://famzil.medium.com/which-front-end-framework-to-learn-in-2020-6bb795ba43b1)
[Medium](https://medium.com/dailyjs/a-realworld-comparison-of-front-end-frameworks-2020-4e50655fe4c1)
[articles](https://mnshjayasundara.medium.com/top-front-end-frameworks-in-2020-f18c079762b0)
[about](https://medium.com/@Systemart/top-10-best-web-development-frameworks-in-2020-2021-657e49cc941)
[UI](https://medium.com/@citrusbug/top-frontend-frameworks-of-2020-for-web-development-c7943f9ba1a9)
[Frameworks](https://medium.com/better-programming/what-will-be-the-best-javascript-framework-in-2021-da4582268419)
in 2020 alone), because we at CL use only one of them: React.

But before we get into why and how we use React, let's touch a bit on...

### Do you even need a framework?

There is such a thing as over-engineering (trust us)---sometimes, plain old JavaScript and CSS are all you need.

Before you start setting up a website using a framework, ask yourself a few questions:
* Am I okay with a larger website (in terms of file size)?
* Do I need the website to be highly responsive and reactive (no pun intended) to user input and interaction?
* Is the website going to have a large number of elements which need to maintain state and complex relationships between each other?
* Do I already know [insert framework here]?

If you answered "no", "not really", or "meh" to all of these, you _don't need a framework_.
If you didn't answer "yes" to all of these, think a little more about if you really need a framework.
But if you answered "yes" to all of these, then keep reading.

### React

[React](https://reactjs.org/) (also known as ReactJS) is a very popular open-source JavaScript library for building complex user interfaces, started and maintained by Facebook (interested in contributing? see [here](https://github.com/facebook/react)).
It's also our go-to UI framework for building more complex websites.

#### Why React?

There are a lot of reasons to use it (and a lot of reasons not to), but the biggest reason we use it here at CL is simply because it's what we're all most knowledgeable about and comfortable with.
But if you're starting a project and you prefer Angular or Vue or something else, then by all means go for it: **the best framework is the one you know**.

#### How do I use React?

This isn't really the place for a full-fledged React tutorial; the documentation has a couple of great starting points for learning the basics (see [here](https://reactjs.org/docs/hello-world.html) and/or [here](https://reactjs.org/tutorial/tutorial.html)).
However, we can touch upon this just briefly; consider anything that's in italics as a piece of terminology for you to look up if you want more information and direction.

Websites are represented in an interface known as the _Document Object Model_, or _DOM_.
Usually, this DOM is expressed in HTML and is what you see when you load any website; what React offers is a _virtual_ DOM, i.e. (roughly speaking) it uses its own internal "fake" DOM, applies any changes that modify the appearance and/or structure of the DOM to that "fake" DOM, and then dynamically replaces the real DOM that's displayed in your browser with the fake one.

The basis of React is the _component_, which is essentially a custom HTML _element_ that you can define and structure yourself.
You can have a component contain other components, forming what is called the _component tree_.
Each component can maintain its own _state_, and modify and read from that state whenever necessary; this forms the core of implementing user interaction in a React app.
Each component can also take its own _properties_, which effectively act as fancier versions of regular HTML _attributes_.

Each component has a lifecycle:
1. The component **mounts** (wherein it is _rendered_ for the first time).
2. The component **updates** whenever its state or properties change (also known as _re-rendering_).
3. The component **unmounts** (wherein it is removed from the DOM).

Traditionally, each React component was its own class (in an object-oriented sense), with member functions such as `componentDidUpdate`, `componentDidMount`, and so on to manage the component based on each stage in its lifecycle.
However, we use something a little different in our projects.

Modern React versions introduced what are known as _functional components_, where each component is actually just a function which returns a component.
This function would then be called whenever the component is re-rendered.
This model eschews dedicated lifecycle methods in favor of more dynamic functions called _hooks_, which do away with the separation of state/property changes from component updates and allow you to hook into (pun intended this time) those changes directly.
Again, the [official React documentation](https://reactjs.org/docs/hooks-intro.html) is a great resource to learn more about this.

## Bundling

As the size and complexity of a website (especially one that utilizes a heavier UI framework like React) increases, it becomes harder and harder to manage.
In such cases, it is helpful to use something called a "bundler", which essentially takes your website's various script files and stylesheets, and consolidates them into tightly-packaged "bundles" (often simply a single script file and stylesheet).

### Why use a bundler?

In addition to consolidating what could be a large number of scripts and stylesheets into a handful of easily-distributable bundles, bundlers are useful for other things.

For one, bundlers often vastly simplify the development process by offering various commands which allow you to easily produce and test development and production builds for your website.
We'll go over what the implications of this are in the next section, **Webpack**.

Bundlers can also be used to automatically _minify_ and _obfuscate_ your code:
* **Minification** is taking a file (such as a JavaScript script) and removing all unnecessary whitespace, unused variables, etc. This can drastically reduce the file sizes of your scripts, greatly improving user experience.
* **Obfuscation** (which goes hand in hand with minification) performs a series of operations on your code, such as replacing all identifiers with unrelated single characters or rearranging code that doesn't need to be executed in the order it was specified, such that the code becomes very difficult to decipher.

### Webpack

There are lots of bundlers out there, such as [Parcel](https://parceljs.org/) or [rollup.js](https://rollupjs.org/guide/en/).
Here at CL, our bundler of choice is [Webpack](https://webpack.js.org/).
Again, there are definitely pros and cons for each bundler (and more millions of Medium article comparisons), but we use Webpack just cause that's what we're used to.

#### How to use Webpack

The best way to learn the ins and outs of Webpack is once again their [official documentation and guides](https://webpack.js.org/guides/).

To install Webpack, you need to---you guessed it---use a package manager.
There are multipl

The basis of Webpack is the Webpack configuration file, usually named something like `webpack.conf.js`.
This configuration file
